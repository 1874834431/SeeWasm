#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import time

from octopus.arch.wasm.utils import extract_mapping
from octopus.arch.wasm.graph import *
from octopus.arch.wasm.utils import Enable_Lasers

import argparse
import sys
import gvar

sys.setrecursionlimit(4096)


def check_not_neg(value):
    # check whether the argument is positive
    ivalue = int(value)
    if ivalue < 0:
        raise argparse.ArgumentTypeError("Random should be a positive number")
    return ivalue


def main():
    parser = argparse.ArgumentParser(
        description='Security Analysis tool for WebAssembly module and Blockchain Smart Contracts (BTC/ETH/NEO/EOS)')

    inputs = parser.add_argument_group('Input arguments')
    inputs.add_argument('-r', '--raw',
                        help='hex-encoded bytecode string ("ABcdeF09..." or "0xABcdeF09...")',
                        metavar='BYTECODE')
    inputs.add_argument('-f', '--file',
                        type=argparse.FileType('rb'),
                        help='binary file (.wasm)',
                        metavar='WASMMODULE')
    inputs.add_argument('-rf', '--rawfile',
                        type=argparse.FileType('r'),
                        metavar='BYTECODE')

    features = parser.add_argument_group('Features')
    features.add_argument('-d', '--disassemble',
                          action='store_true',
                          help='print text disassembly')
    features.add_argument('-v', '--verbose',
                          action='store_true',
                          help='switch the logging to debug level')
    features.add_argument('-z', '--analyzer',
                          action='store_true',
                          help='print module information')
    features.add_argument('-y', '--analytic',
                          action='store_true',
                          help='print Functions instructions analytics')
    features.add_argument('-g', '--cfg',
                          action='store_true',
                          help='generate the control flow graph (CFG) (instruction level)')
    features.add_argument('-c', '--call',
                          action='store_true',
                          help='generate the call flow graph (function level)')
    features.add_argument('-q', '--quick',
                          action='store_true',
                          help='use this flag to get scanner result before full coverage')
    features.add_argument('--need_mapper',
                          action='store_true',
                          help='give a mapping structure: func index to func name, e.g., {4: "$main"}')
    features.add_argument('--random',
                          type=check_not_neg,
                          help='how many branches will be randomly selected in internal call instruction')
    features.add_argument('--depth',
                          type=check_not_neg,
                          default=2,
                          help='how many layers of internal call')
    features.add_argument('--timeout',
                          type=check_not_neg,
                          default=5,
                          help='how many minutes can be endured when executing, default is 30')
    features.add_argument('--manual_guide',
                          action='store_true',
                          help='allow users to manually guide the control flow')

    # vulnerability detector
    lasers = parser.add_argument_group('Lasers')
    lasers.add_argument('--overflow', action='store_true',
                        help="fire the overflow vulnerability detector")
    lasers.add_argument('--divzero', action='store_true',
                        help="fire the div-zero vulnerability detector")

    analyze = parser.add_mutually_exclusive_group(required=False)
    analyze.add_argument('-s', '--symbolic',
                         action='store_true',
                         help='perform the symbolic execution for EOS contract')
    analyze.add_argument('-l', '--lasers',
                         nargs='+',
                         help='specify the list of module name of lasers')

    graph = parser.add_argument_group('Graph options')
    graph.add_argument('--simplify', action='store_true',
                       help='generate a simplify CFG')
    graph.add_argument('--functions', action='store_true',
                       help='create subgraph for each function')
    graph.add_argument('--onlyfunc', type=str,
                       nargs="*",
                       default=[],
                       help='only generate the CFG for this list of function name')

    args = parser.parse_args()

    octo_bytecode = None
    octo_analyzer = None
    octo_disasm = None
    octo_cfg = None
    func_index2func_name = None

    # the verbose
    if args.verbose:
        gvar.logging_level_verbose = True

    # process input file
    if args.file:
        # func_index2func_name is the func index to real func name
        # e.g., func 4 is $main, we have {4: '$main'}
        if args.need_mapper:
            wat_file_path = args.file.name.replace('.wasm', '.wat')
            func_index2func_name = extract_mapping(wat_file_path)

        octo_bytecode = args.file.read()
    elif args.rawfile:
        octo_bytecode = args.rawfile.read()
        octo_bytecode = bytearray.fromhex(octo_bytecode)

    # Disassembly
    if args.disassemble:
        from octopus.arch.wasm.disassembler import WasmDisassembler

        # TODO [official] add other r_format support
        octo_disasm = WasmDisassembler()
        print(octo_disasm.disassemble_module(octo_bytecode, r_format='text'))

    if args.analyzer:
        from octopus.arch.wasm.analyzer import WasmModuleAnalyzer

        octo_analyzer = WasmModuleAnalyzer(octo_bytecode)
        print(octo_analyzer)

    # Control Flow Analysis & Call flow Analysis
    if args.cfg or args.call or args.analytic:
        from octopus.arch.wasm.cfg import WasmCFG
        from octopus.analysis.graph import CFGGraph

        octo_cfg = WasmCFG(octo_bytecode)

        if args.call:
            octo_cfg.visualize_call_flow()
        if args.analytic:
            octo_cfg.visualize_instrs_per_funcs()

        if args.cfg:
            octo_graph = CFGGraph(octo_cfg)
            if args.functions or args.onlyfunc:
                octo_graph.view_functions(only_func_name=args.onlyfunc,
                                          simplify=args.simplify
                                          )
            else:
                octo_graph.view(simplify=args.simplify)

    # import necessary library
    from octopus.arch.wasm.emulator_revise import WasmSSAEmulatorEngine
    if args.symbolic:
        # record the lasers that users required
        user_asked_lasers = 0
        if args.overflow:
            user_asked_lasers ^= Enable_Lasers.OVERFLOW.value
        if args.divzero:
            user_asked_lasers ^= Enable_Lasers.DIVZERO.value

        wasmVM = WasmSSAEmulatorEngine(
            octo_bytecode, user_asked_lasers, func_index2func_name=func_index2func_name)
        # run the emulator for SSA
        Graph.wasmVM = wasmVM
        Graph.manual_guide = args.manual_guide
        Graph.extract_basic_blocks()
        if args.onlyfunc:
            graph = Graph(args.onlyfunc)
            graph.traverse()
        else:
            raise Exception("Please specify at least one entry function")

    if not args.disassemble and not args.symbolic \
            and not args.cfg and not args.call and not args.lasers \
            and not args.analyzer and not args.analytic:
        parser.print_help()


if __name__ == '__main__':
    main()
