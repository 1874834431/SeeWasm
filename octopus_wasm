#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from octopus.arch.wasm.security import fire_lasers_by_module_name, engine_start
import argparse
import logging
import sys

sys.setrecursionlimit(4096)


# set log level
# logging.basicConfig(filename='./logs/tmp.log',
#                     filemode='w',
#                     level=logging.WARNING)
# logging.basicConfig(level=logging.INFO)


# check whether the argument is positive
def check_not_neg(value):
    ivalue = int(value)
    if ivalue < 0:
        raise argparse.ArgumentTypeError("Random should be a positive number")
    return ivalue


def main():
    parser = argparse.ArgumentParser(
        description='Security Analysis tool for WebAssembly module and Blockchain Smart Contracts (BTC/ETH/NEO/EOS)')

    inputs = parser.add_argument_group('Input arguments')
    inputs.add_argument('-r', '--raw',
                        help='hex-encoded bytecode string ("ABcdeF09..." or "0xABcdeF09...")',
                        metavar='BYTECODE')
    inputs.add_argument('-f', '--file',
                        type=argparse.FileType('rb'),
                        help='binary file (.wasm)',
                        metavar='WASMMODULE')
    inputs.add_argument('-rf', '--rawfile',
                        type=argparse.FileType('r'),
                        metavar='BYTECODE')

    # input_file_type = parser.add_argument_group('Input file type')
    # input_file_type.add_argument('--file_type',
    #                              default='eos',
    #                              const='eos',
    #                              nargs='?',
    #                              choices=['eos', 'c', 'golang'],
    #                              help='The file type of input file, e.g., eos, golang, c')

    features = parser.add_argument_group('Features')
    features.add_argument('-d', '--disassemble',
                          action='store_true',
                          help='print text disassembly ')
    features.add_argument('-z', '--analyzer',
                          action='store_true',
                          help='print module information')
    features.add_argument('-y', '--analytic',
                          action='store_true',
                          help='print Functions instructions analytics')
    features.add_argument('-g', '--cfg',
                          action='store_true',
                          help='generate the control flow graph (CFG) (instruction level)')
    features.add_argument('-c', '--call',
                          action='store_true',
                          help='generate the call flow graph (function level)')
    features.add_argument('-q', '--quick',
                          action='store_true',
                          help='use this flag to get scanner result before full coverage')
    features.add_argument('--random',
                          type=check_not_neg,
                          help='how many branches will be randomly selected in internal call instruction')
    features.add_argument('--depth',
                          type=check_not_neg,
                          default=2,
                          help='how many layers of internal call')
    features.add_argument('--timeout',
                          type=check_not_neg,
                          # for other detectors
                          # default=8,
                          # i'd rather choose 3 as default when run fake receipt
                          default=5,
                          help='how many minutes can be endured when executing, default is 30')

    analyze = parser.add_mutually_exclusive_group(required=False)
    analyze.add_argument('-s', '--symbolic',
                         action='store_true',
                         help='perform the symbolic execution for EOS contract')
    analyze.add_argument('-l', '--lasers',
                         nargs='+',
                         help='specify the list of module name of lasers')

    graph = parser.add_argument_group('Graph options')
    graph.add_argument('--simplify', action='store_true',
                       help='generate a simplify CFG')
    graph.add_argument('--functions', action='store_true',
                       help='create subgraph for each function')
    graph.add_argument('--onlyfunc', type=str,
                       nargs="*",
                       default=[],
                       help='only generate the CFG for this list of function name')
    # graph.add_argument('--visualize',
    #                   help='direcly open the CFG file')
    # graph.add_argument('--format',
    #                   choices=['pdf', 'png', 'dot'],
    #                   default='pdf',
    #                   help='direcly open the CFG file')

    args = parser.parse_args()

    octo_bytecode = None
    octo_analyzer = None
    octo_disasm = None
    octo_cfg = None

    # process input code
    # if args.raw:
    #     octo_bytecode = args.raw
    #     octo_bytecode = bytearray.fromhex(octo_bytecode)
    if args.file:
        octo_bytecode = args.file.read()
    elif args.rawfile:
        octo_bytecode = args.rawfile.read()
        octo_bytecode = bytearray.fromhex(octo_bytecode)

    # print(octo_bytecode)
    # Disassembly
    if args.disassemble:
        from octopus.arch.wasm.disassembler import WasmDisassembler

        # TODO add other r_format support
        octo_disasm = WasmDisassembler()
        print(octo_disasm.disassemble_module(octo_bytecode, r_format='text'))

    if args.analyzer:
        from octopus.arch.wasm.analyzer import WasmModuleAnalyzer

        octo_analyzer = WasmModuleAnalyzer(octo_bytecode)
        print(octo_analyzer)

    # Control Flow Analysis & Call flow Analysis
    if args.cfg or args.call or args.analytic:
        from octopus.arch.wasm.cfg import WasmCFG
        from octopus.analysis.graph import CFGGraph

        octo_cfg = WasmCFG(octo_bytecode)

        if args.call:
            octo_cfg.visualize_call_flow()
        if args.analytic:
            octo_cfg.visualize_instrs_per_funcs()

        if args.cfg:
            octo_graph = CFGGraph(octo_cfg)
            if args.functions or args.onlyfunc:
                octo_graph.view_functions(only_func_name=args.onlyfunc,
                                          simplify=args.simplify
                                          )
            else:
                octo_graph.view(simplify=args.simplify)

    # import necessary library
    from octopus.arch.wasm.emulator import WasmSSAEmulatorEngine
    if args.symbolic:
        wasmVM = WasmSSAEmulatorEngine(
            octo_bytecode, args.random, args.timeout, args.depth)
        # run the emulator for SSA
        if args.onlyfunc:
            wasmVM.emulate_functions(args.depth, list_functions_name=args.onlyfunc)
        # try to emulate main by default
        else:
            wasmVM.emulate_functions(args.depth)
    elif args.lasers:
        # print(args.file)
        if not args.quick:
            wasmVM = WasmSSAEmulatorEngine(
                octo_bytecode, args.random, args.timeout, args.depth)

            # dicecenter
            # sym_exe, index2state = wasmVM.emulate_functions(list_functions_name=['$func51'])

            # eosbiggame
            # sym_exe, index2state = wasmVM.emulate_functions(list_functions_name=['_ZN7biggame4dice6revealEyRK11checksum256'])

            # other cases
            # if the only laser is not the fake_eos, jump over the apply because of the static strategy
            sym_exe, index2state = None, None
            if args.lasers == ['fake_eos'] or args.lasers == ['auth_check']:
                sym_exe, index2state = wasmVM.emulate_functions(args.depth, list_functions_name=['apply'])

            logging.info("module: %s" % args.lasers)
            for laser in args.lasers:
                issues = fire_lasers_by_module_name(
                    wasmVM, sym_exe, index2state, laser)
                # for test 'random' module
                # issues = fire_lasers_by_module_name(wasmVM, [], {}, laser)

                logging.info("issues: %s" % (issues))
                sys.stdout.write(issues)
        else:
            wasmVM = WasmSSAEmulatorEngine(
                octo_bytecode, args.random, args.timeout, args.depth, args.lasers, args.quick)
            engine_start(wasmVM)

        # visualization of the cfg with SSA
        # emul.cfg.visualize(ssa=False)

    # # if we try to analyze the C file
    # if args.file_type == 'c':
    #     from octopus.arch.wasm.emulator import WasmSSAEmulatorEngine
    #     wasmVM = WasmSSAEmulatorEngine(
    #         octo_bytecode, args.random, args.timeout, args.depth)
    #     sym_exe, index2state = None, None
    #     sym_exe, index2state = wasmVM.emulate_functions(
    #         list_functions_name=['main'])

    if not args.disassemble and not args.symbolic \
            and not args.cfg and not args.call and not args.lasers \
            and not args.analyzer and not args.analytic:
        parser.print_help()


if __name__ == '__main__':
    main()
